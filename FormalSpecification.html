<html>
    <head>
        <title>Formal Specification</title>
        <link rel="stylesheet" href="Main.css">
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    </head>
    <body>
        <div class="Main-Div">
            <a name='Top'></a>
            <h1>Tom & Loughborough University - Formal Specification</h1>
            <div id="Back-Button-Div">
                <input type="button" class="Back Button" onclick="window.location = 'UniversityModules.html';" value="Back to University Modules">
                <input type="button" class="Back Button" onclick="window.location = '#Top';" value="Back to Top">
            </div>
            <br/>
            <div class="Sub-Div">
                <p>Formal Specification is used for verification and manipulation, reducing 
                    contradictions and ambiguity, abstraction and as a shorthand.</p>
                <br/>
                <u>Testing vs. Verification</u>
                <p>Testing tells us if there are bugs in the program. Verification tells us if 
                    there are no bugs in a program. These aspects are important for a system that 
                    relies heavily on software and should failure happen, it could lead to grave 
                    consequences. Examples include nuclear reactors, air and spacecraft, medical 
                    applications and defense applications.<br/>To prove a program correct it needs 
                    to be run against a specification.</p>
                <br/>
                <u>Verification vs. Correctness by Construction</u>
                <p>There are two approaches to guarantee a bug-free program. The first approach is 
                    to write a specification and then write a program, then prove the program 
                    correct against the specification.<br/>The other approach is to write the 
                    specification and then manipulate it in a way which preserves correctness until 
                    an executable specification and thus a program is produced.<br/>The Vienna 
                    Development is an example used in the first approach.</p>
                <br/>
                <u>Drawbacks of Specification in English</u>
                <p>With multiple different objects in a class in a program, these objects can be 
                    inconsistent and confusing against one another. The initial requirements could 
                    be different from the worked out requirements making them contradictory. By 
                    specifying the requirements in a formal mathematical language, we have been 
                    able to manipulate and analyze them and identify inconsistencies.<br/>
                    Requirements leave certain options available and are not always a problem as 
                    either requirement could be chosen to utilize.</p>
                <br/>
                <u>Drawbacks of Specification in a Programming Language</u>
                <p>Ambiguity is eliminated if, instead of using an English specification, a 
                    programming language is used.</p>
                <br/>
                <u>Abstraction & Precision</u>
                <p>English specifications can be very abstract but are liable to be ambiguous and 
                    imprecise. The problem with a specification in a programming language is that a 
                    specification must be sufficiently abstract to encompass all possible 
                    implementations. When converting an English language specification into a 
                    programming language specification will achieve precision and lose ambiguity but 
                    loses abstraction.<br/>If two programs provide two different functions they may 
                    be different but they can have the same abstract behaviour as they go from being 
                    in a start state, through execution into an end state. If they both go from $x$ to 
                    $x_2$ then they have the same abstract behaviour. If another program was strung 
                    on the end of either two programs that produce $x_2$ and the new program uses 
                    the returned value as a parameter, the execution of the two procedures are 
                    essentially the same.</p>
                <br/>
                <u>Design of Formal Specifications</u>
                <p>Design is largely a creative activity, which demands finding patterns to work 
                    out specifications as well as coming up with proofs.<br/>Specification 
                    techniques like UML are informal specification techniques as they lack 
                    precision and offer no scope for proofs or correctness.</p>
                <br/>
                <u>Formal Specification & Decomposing Design</u>
                <p> - Breaking down the problem into smaller more manageable chunks helps make the 
                    overall problem more solvable.<br/>
                    - Specifications should then be broken down as well to accompany each 
                    individual </p>
                <br/>
                <u>Classification of Formal Specification Languages</u>
                <p>Specifications that are formal can either be model-oriented or 
                    property-oriented.<br/>Specifications can also be used for concurrent systems 
                    although this will not be covered.</p>
                <br/>
                <u>Model-oriented vs. Property-oriented Specification</u>
                <p>In model-oriented specifications, operations are defined on system data made up 
                    of structures built-up from assumed simple types such as sets. Operations are 
                    also defined individually in terms of their effect on the system state. 
                    Model-oriented specifications are proved correct using logic and set theory.<br/>
                    In property-oriented specifications, the behaviour of operations is described in 
                    terms of how two or more of them interact - they are never defined individually. 
                    Property-oriented specifications are proved correct algebraically, by using 
                    equational reasoning.<br/>Algebraic proofs can be easier than proofs in logic 
                    and set theory, however not all systems can be specified satisfactorily, solely 
                    in terms of how operations interact.<br/>
                    <img src='Formal Specification/Image1.jpg' alt='First Image' style='max-width: 100%;'><br/>
                    Above is a property-oriented specification of stacks.<br/>
                    <img src='Formal Specification/Image2.jpg' alt='Second Image' style='max-width: 100%;'><br/>
                    Above is a property-oriented specification of queues.<br/>
                    <img src='Formal Specification/Image3.jpg' alt='Third Image' style='max-width: 100%;'><br/>
                    Above is a property-oriented specification for non-negative integers.<br/>
                    <img src='Formal Specification/Image4.jpg' alt='Fourth Image' style='max-width: 100%;'><br/>
                    Above is an example of a proof.</p>
                <br/>
                <u>Real-life Use of Formal Methods</u>
                <p>Real-life use of formal methods is more scarce nowadays as it requires highly 
                    skilled people and costs a lot to provide for even a small program to prove it 
                    correct. System development will also always be a human activity.<br/>Formal 
                    methods do however provide a reduction in the likelihood of human error, 
                    identification of errors and inconsistencies missed by conventional 
                    development methods. It can be cost-effective as well if the costs of using 
                    formal methods are counter-balanced by the huge savings in not having to 
                    return design stage due to major design errors found at late stage 
                    development.<br/>Formal methods should be used if the organization, the 
                    current stage of development and the expertise available are all 
                    appropriate.</p>
                <br/>
                <u>Formal Methods & Structured Methods</u>
                <p>Even though formal methods are superior to structured methods in many ways, it 
                    is not realistic to assume that formal methods could ever replace structure 
                    methods as they stand.</p>
                <br/>
                <u>Logic of Partial Functions</u><br/>
                <u>Notation for Partial Sets</u>
                <p>$\mathbb{N}$ is the symbol to describe the set of natural numbers. The standard 
                    set will output all possible natural numbers from 0 onwards. If a subscript 1 
                    or any other number is given after the $\mathbb{N}$ set will start from 1.<br/>
                    $\mathbb{Z}$ is the symbol to describe the standard set of integers. Integers 
                    are non-decimal numbers that can be positive or negative, including 0.<br/>
                    $\mathbb{R}$ is the symbol to describe the standard set of real numbers. Real 
                    numbers are essentially boundless in their syntax. They can be floating point 
                    numbers or integers, positive or negative as well as the irrational numbers 
                    like $\pi$, etc.</p>
                <br/>
                <u>Functions</u>
                <p>A (total) function is a mapping between two sets of values and the signature of 
                    the function is shown in the form:<br/>
                    $f:X\rightarrow Y$<br/>
                    - f is the name for the function<br/>
                    - X is the set of values, called the domain, which are mapped by f to Y<br/>
                    - Y is called the range<br/>
                    $f:{\text{fred}, \text{bill}, \text{joe}}\rightarrow{\text{freda}, \text{gertie}}$<br/>
                    This is an example function mapping...<br/>
                    $f(\text{fred})\triangle \text{gertie}, f(\text{bill})\triangle\text{gertie}, f(\text{joe})\triangle\text{freda}$<br/>
                    The above is the individual mapping relations with the previous function.<br/>
                    Functions with infinite domains are defined in terms of already understood 
                    functions by the use of variables:<br/>
                    $g:Z\rightarrow N, g(i)\triangle i(i)$<br/>
                    A signature must be given when defining a function. With the above example, 
                    the first half of the function is the function (g) and the second half of the 
                    function is the application of the function with regards to the infinitely 
                    expansive domain.</p>
                <br/>
                <u>Partial Functions</u>
                <p>A partial function with $f:X\rightarrow Y$ maps some of the elements X to Y, 
                    but some values of X will map to an undefined value.<br/>
                    $h:{\text{fred}, \text{bill}, \text{joe}}\rightarrow{\text{fred}, \text{gertie}}$<br/>
                    $h(\text{fred})\triangle\text{gertie}, h(\text{bill})\triangle\text{undefined}, h(\text{joe})\triangle\text{freda}$<br/>
                    The domain value of bill maps to nothing with regards to the above function 
                    definition.<br/>A total function can be extracted from a partial function by 
                    restricting the partial function's domain. In this case, the above function 
                    will change to:<br/>
                    $h:{\text{fred}, \text{joe}}\rightarrow{\text{freda}, \text{gertie}}$<br/>
                    $h(\text{fred})\triangle\text{gertie}, h(\text{joe})\triangle\text{freda}$<br/>
                    Here, one value of the domain - bill - has been removed as bill was the only 
                    domain value mapping to nothing.<br/>
                    $\text{divide}:Z\times Z\rightarrow R$<br/>
                    $\text{divide}(x_1,x_2 )\triangle\frac{x_1}{x_2}  (x_2\ne 0)$,<br/>
                    $\text{divide}(x_1, 0)\triangle\text{undefined}$<br/>
                    Propositions can therefore, with this newly applied knowledge, be part of the 
                    boolean set of three possible values: true, false or undefined. (Undefined is 
                    notated using an *).</p>
                <br/>
                <u>Propositional Operators</u>
                <p>Propositional, or binary operators combine propositions and whatever their 
                    individual boolean values are, they are cross-referenced to accumulate an 
                    overall boolean value for the operated propositions.<br/>
                    $(\lnot2+2=5)\wedge(3-2=6\wedge1=1)$<br/>
                    Can be written as:<br/>
                    $\lnot2+2=5\wedge3-2=6\wedge1=1$<br/>
                    Evaluated, this statement can be decomposed and solved as follows:<br/>
                    $\lnot2+2=5$ accumulates to true, as any value that isn't 2 plus 2 makes 5. The 
                    value that isn't two can be 3 to make 5.<br/>
                    3-2=6 accumulates to false as 3-2 is 1 and not 6.<br/>
                    1=1 accumulates to true as 1 is 1.<br/>
                    $\lnot2+2=5\wedge3-2=6$ accumulates to false, as the two propositions already 
                    solved are true and false respectively. The operator is an AND, and with this 
                    operator, if the two values are true and false, the overall boolean value is 
                    false.<br/>
                    $\lnot2+2=5\wedge3-2=6\wedge1=1$ accumulates to false. This is because the 
                    operated two propositions accumulate to false and the other proposition 
                    accumulates to true. Again, ANDed propositions with values of true and false 
                    accumulate to false, meaning the overall statement is false.<br/>
                    $\lnot, \wedge, \vee, \Rightarrow, \Leftrightarrow$<br/>
                    Above is the descending priority hierarchy of the operators. In the example we 
                    just solved, priority isn't really a problem as multiple AND operators in one 
                    statement are commutative. Also, as propositional logic is lazily operated, 
                    the algorithm will realize that the overall statement is false prior to 
                    working out all the proposition values. (Once one false value is found in a 
                    statement that only involves AND operators, the whole statement will instantly 
                    become false.)</p>
                <br/>
                <u>Truth Tables</u>
                <p><img src='Formal Specification/Image5.jpg' alt='Fifth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image6.jpg' alt='Sixth Image' style='max-width: 100%;'><br/>
                    Under the law of the excluded middle, it states that:<br/>
                    $E\vee\lnot E$<br/>
                    Will be true for any proposition E. In 3-valued logic, $E\vee\lnot E$ will 
                    evaluate to not true as it relies on E being defined.<br/>We wish to use 
                    partial functions and the advantage of the 3-valued logic is that statements 
                    such as<br/>
                    $\frac 50=1\vee\frac 50\ne 1$<br/>
                    Will output undefined rather than true, but obviously only in 3-valued logic 
                    where the undefined value is available. Therefore the definition for 
                    predicates can be extended to support 3-valued logic by assuming the outputted 
                    boolean value could now also be undefined.</p>
                <br/>
                <u>Implicit Specification of Functions</u>
                <p>Example:<br/>
                    $\textit{Maxs}(s : \mathbb{N}-\textit{set})r :\mathbb{N}$<br/>
                    $\textit{pre} s \ne\text{{ }}$<br/>
                    $\textit{post} r\in s\wedge \forall i\in s.i\leq r$</p>
                <br/>
                <u>Keyword Form</u>
                <p>A function, maxs has input(s) within the parentheses after the function 
                    identifier. After the parentheses comes the output(s). Both inputs and outputs 
                    all have to have their data type specified. The pre-condition are the 
                    conditions that have to be met before the function is carried out and the 
                    post-condition is how the output has to be after the function has been carried 
                    out. Any function with a pre-condition is a partial function. An implicit 
                    specification can allow for many satisfied post-conditions with one single 
                    input. The pre-condition can only specify the inputs and the post-condition 
                    can specify both the inputs and/or the outputs.</p>
                <br/>
                <u>Direct Definition Form</u>
                <p>$\textit{pre}-f:T_p\rightarrow\textit{Boolean}$<br/>
                    $\textit{post}-f:T_p\times T_r\rightarrow\textit{Boolean}$<br/>
                    Of the form:<br/>
                    $\textit{pre}-f(p)\triangle...p...$<br/>
                    $\textit{post}-f(p,r)\triangle...p...r...$<br/>
                    The direct definition of maxs is therefore:<br/>
                    $\textit{pre}-\textit{maxs}:\mathbb{N}-\textit{set}\rightarrow\textit{Boolean}$<br/>
                    $\textit{post}-\textit{maxs}:\mathbb{N}-\textit{set}\times\mathbb{N}\rightarrow\textit{Boolean}$<br/>
                    $\textit{pre}-\textit{maxs}(s)\triangle s\ne\text{{ }}$<br/>
                    $\textit{post-maxs}(s,r)\triangle r\in s\wedge\forall i\in s.i\leq r$</p>
                <br/>
                <u>Definition by Recursion</u>
                <p>$\textit{sq}:\mathbb{N}\rightarrow\mathbb{N}$<br/>
                    $\textit{sq}(i)\triangle \textit{ if }i=0\textit{ then }0\textit{ else }2\ast i-1+\textit{sq}(i-1)$<br/>
                    $\textit{subp}:\mathbb{Z}\times\mathbb{Z}\rightarrow\mathbb{N}$<br/>
                    $\textit{subp}(i,j)\triangle\textit{ if }i=j\textit{ then }0\textit{ else subp}(i,j+1)+1$</p>
                <br/>
                <u>The 'Let in' Notation</u>
                <p>$\textit{absprod}:\mathbb{Z}\times\mathbb{Z}\rightarrow\mathbb{N}$<br/>
                    $\textit{absprod}(i,j)\triangle\textit{ if }i*j<0\textit{ then }-(i*j)\textit{ else }i*j$</p>
                <br/>
                <u>Correctness Proofs - Satisfaction</u>
                <p>We need to prove that:<br/>Explicit definition of function ("implementation")<br/>
                    Satisfies<br/>Implicit definition of function ("specification")</p>
                <br/>
                <u>Implicit Definition</u>
                <p>$\textit{pre-f}:T_p\rightarrow\textit{Boolean}$<br/>
                    $\textit{post-f}:T_p\times T_r\rightarrow\textit{Boolean}$<br/>
                    $\textit{pre-f}(p)\triangle...p...$<br/>
                    $\textit{post-f}(p,r)\triangle...p...r...$</p>
                <br/>
                <u>Explicit Definition</u>
                <p>$f:T_p\rightarrow T_r$<br/>
                    $f(...)\triangle...$</p>
                <br/>
                <u>Proof Obligation</u>
                <p>$\forall p\in T_p.\textit{pre-f}(p)\Rightarrow f(p)\in T_r\wedge \textit{post-f}(p,f(p))0$<br/>
                    The proof obligation says that for values that satisfy the pre-condition the 
                    evaluation of the explicit definition satisfies the post condition.<br/>
                    For values which do not satisfy the pre-condition, the implementation 
                    (explicit definition) is allowed to do anything. Indeed, the explicit 
                    definition may be a partial function which is undefined where the 
                    pre-condition is not satisfied.<br/>Example:</p>
                <br/>
                <u>Implicit Definition</u>
                <p>$\textit{max}(i:\mathbb{Z},j:\mathbb{Z},r:\mathbb{Z})$<br/>
                    $\textit{pre true}$<br/>
                    $\textit{post} (r=i\vee r=j)\wedge i\leq r\wedge j\leq r$</p>
                <br/>
                <u>Explicit Definition</u>
                <p>$\textit{max}:\mathbb{Z}\times\mathbb{Z}\rightarrow\mathbb{Z}$<br/>
                    $\textit{max}(i,j)\triangle \textit {if }i\leq j\textit{ then }j\textit{ else }i$</p>
                <br/>
                <u>Proof Obligation</u>
                <p>$\forall i\in\mathbb{Z}.\forall j\in\mathbb{Z}.\textit{true}\Rightarrow\textit{max}(i,j)\in\mathbb{Z}\wedge((\textit{max}(i,j)=i\vee$<br/>
                    $\textit{max}(i,j)=j)\wedge i\leq\textit{max}(i,j)\wedge j\leq\textit{max}(i,j))$</p>
                <br/>
                <u>Correctness Proofs - Satisfiability</u>
                <p>Contradictory specifications can be written in the English language, but can 
                    also be written in VDM as well.<br/>
                    $\textit{pre-f}:T_p\rightarrow\textit{Boolean}$<br/>
                    $\textit{post-f}:T_p\times T_r\rightarrow\textit{Boolean}$<br/>
                    Is satisfiable if<br/>
                    $\forall p\in T_p.\textit{pre-f}(p)\Rightarrow\exists r\in T_r.\textit{post-f}(p,r)$<br/>
                    $\textit{betweenreal}(i:\mathbb{R},r:\mathbb{R})$<br/>
                    $\textit{pre true}$<br/>
                    $\textit{post} (2i< r)\wedge(r<2i+1)$<br/>
                    Is satisfiable if<br/>
                    $\forall p\in R.\textit{true}\Rightarrow\exists r\in\mathbb{R}.(2p< r)\wedge(r<2p+1)$<br/>
                    This is satisfiable.<br/>
                    $\textit{betweeninteger}(i:\mathbb{Z},r:\mathbb{Z})$<br/>
                    $\textit{pre true}$<br/>
                    $\textit{post}(2i< r)\wedge(r<2i+1)$<br/>
                    Is satisfiable if<br/>
                    $\forall p\in \mathbb{Z}.\textit{true}\Rightarrow\exists r\in \mathbb{Z}.(2p< r)\wedge(r<2p+1)$<br/>
                    This is not satisfiable.<br/>
                    For two inputs, the specification is the same, however, two input values, 
                    $T_{p1}$ and $T_{p2}$ that are both incorporated into the pre-condition and 
                    the post-condition.<br/>
                    $\textit{lowupbounds}(s,t:\mathbb{N}-\textit{set})r:\mathbb{N}\times\mathbb{N}$<br/>
                    $\textit{pre } s\ne\textit{{ }}\wedge t\ne\textit{{ }}$<br/>
                    $\textit{post }\exists r_1\in\mathbb{N}.\exists r_2\in\mathbb{N}.\forall i\in s.\forall j\in t.r_1\leq i\wedge j\leq r_2\wedge$<br/>
                    $r=(r_1,r_2)$<br/>
                    Is satisfiable if<br/>
                    $\forall s\in\mathbb{N}-\textit{set}.\forall t\in\mathbb{N}-\textit{set}.s\ne\textit{{ }}\wedge$<br/>
                    $t\ne\textit{{ }}\Rightarrow\exists r\in\mathbb{N}\times\mathbb{N}.\exists r_1\in\mathbb{N}.\exists r_2\in\mathbb{N}.\forall i\in s.\forall j\in t.r_1\leq i$<br/>
                    $\wedge j\leq r_2\wedge r=(r_1,r_2)$<br/>
                    <img src='Formal Specification/Image7.jpg' alt='Seventh Image' style='max-width: 100%;'></p>
                <br/>
                <u>Specification of Operations</u>
                <p>Storing a value into a calculator using an operation specification:<br/>
                    $\textit{LOAD}(i:\mathbb{N})$<br/>
                    $\textit{ext wr reg}:\mathbb{N}$<br/>
                    $\textit{post reg}=i$<br/>
                    The name of the operation is in uppercase, the ext part records the variables 
                    to which the operation has external access. Wr or rd define whether the 
                    external variables can be written to or simply just read. The post-condition 
                    depends on the parameters and the values of the external variables. A hook 
                    above a variable identifier specifies the original value of the variable.<br/>
                    An operation specification with external read access to one variable and 
                    external write access to another is written as so:<br/>
                    $\textit{OP}(p:T_p)r:T_r$<br/>
                    $\textit{ext rd }v_1:T_1$<br/>
                    $\textit{ext wr }v_2:T_2$<br/>
                    $\textit{pre}...p...v_1...v_2...$<br/>
                    $\textit{post}...p...v_1...v_2 (\textit{original})...r...v_2...$<br/>
                    With functions we prove that explicit definitions satisfy implicit 
                    specifications. When it comes to programs, we want to prove that an 
                    implementation satisfies a specification. An implementation of a program is a 
                    sequence of program statements, which is a sequence of operations. A 
                    specification of a program is of a single operation. Therefore, we need to be 
                    able to prove that a sequence of smaller operations satisfies the 
                    specification of a single, larger operation.<br/>
                    $\textit{OP1}$<br/>
                    $\textit{ext wr }u_1,...,u_n:T$<br/>
                    $\textit{pre pre-OP1}(u_1,...,u_n)$<br/>
                    $\textit{post post-OP1}(u_1,...,u_n (\textit{original}),u_1,...,u_n )$<br/>
                    $\textit{OP2}$<br/>
                    $\textit{ext wr }u_1,...,u_n:T$<br/>
                    $\textit{pre pre-OP2}(u_1,...,u_n )$<br/>
                    $\textit{post post-OP2}(u_1,...,u_n (\textit{original}),u_1,...,u_n )$<br/>
                    And that<br/>
                    $\forall u_1\in T...\forall u_n\in T.\forall u_1\in T...\forall u_n\in T.$<br/>
                    $\textit{pre-OP1}(u_1,...,u_n (\textit{original}))\wedge\textit{post-OP1}$<br/>
                    $(u_1,...,u_n,u_1,...,u_n )\Rightarrow\textit{pre-OP2}(u_1,...,u_n )$<br/>
                    <img src='Formal Specification/Image8.jpg' alt='Eighth Image' style='max-width: 100%;'></p>
                <br/>
                <u>Operation Decomposition Correctness</u>
                <p>If<br/>
                    <img src='Formal Specification/Image9.jpg' alt='Ninth Image' style='max-width: 100%;'><br/>
                    Is an abstract specification of an operation, then OP1;OP2 satisfy OP (or OP 
                    is correctly decomposed into OP1;OP2<br/>
                    If<br/>
                    <img src='Formal Specification/Image10.jpg' alt='Tenth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image11.jpg' alt='Eleventh Image' style='max-width: 100%;'></p>
                <br/>
                <u>Model-oriented Specification of Data Types</u><br/>
                <u>Sets</u>
                <p>The union of two sets, denoted by $\cup$, is a set containing all the elements 
                    of both sets with any duplicate elements removed.<br/>The intersection is a 
                    set containing the mutual elements of both sets.<br/>Two sets are disjoint if 
                    they have an empty set as the intersection of the two sets. This means that 
                    the elements of both sets are completely unique from the other set.<br/>The 
                    difference of two sets, denoted by a -, is the set of elements in the first 
                    set mentioned, which are not in the other set.<br/>A set X is a subset of Y if 
                    every element of X is in Y. X would be a proper subset of Y if X is a subset 
                    of Y but X isn't equal to Y; much like the difference between < and $\leq$.<br/>
                    A set Y is a partition of a set X if the set Y is made up of a number of sets 
                    which, overall contain only and all the elements in X.<br/>The distributed 
                    union of a set of sets X is the union of all the sets in X.</p>
                <br/>
                <u>Set Comprehension</u>
                <p>Set comprehension defines a set that satisfies a certain property or properties 
                    where the prior known sets were either finite or infinite.<br/>The notation is 
                    split by a | and to the left of it, shows the data type of the set, and to the 
                    right of it, defines the constraint.</p>
                <br/>
                <u>Example for a Raffle</u>
                <p><img src='Formal Specification/Image12.jpg' alt='Twelvth Image' style='max-width: 100%;'></p>
                <br/>
                <u>Defining Composite Objects</u>
                <p>$\textit{Compose Datec of}$<br/>
                    $\textit{Day} : \lbrace1,...,366\rbrace$<br/>
                    $\textit{Year} : \mathbb{N}$<br/>
                    $\textit{End}$<br/>
                    $\textit{Or}$<br/>
                    $\textit{Datec} :: \textit{day} : \lbrace1,...,366\rbrace$<br/>
                    $\textit{year} : \mathbb{N}$<br/>
                    $\textit{Datec}=\lbrace\textit{mk-Datec}(d,y)|d\in{1,...,366}\wedge y\in\mathbb{N}\rbrace$<br/>
                    $\textit{Mk-Datec is a function where}:$<br/>
                    $\textit{mk-Datec}:\lbrace1,...,366\rbrace\times\mathbb{N}\rightarrow\textit{Datec}$<br/>
                    The mk will help define the difference between two functions where the input 
                    parameters are the same, making them look visually ambiguous.</p>
                <br/>
                <u>Decomposing Objects</u>
                <p>Objects can be decomposed to give the individual parameters where:<br/>
                    $\textit{day}:\textit{Datec}\rightarrow\lbrace1,...,366\rbrace$<br/>
                    $\textit{year}:\textit{Datec}\rightarrow\mathbb{N}$</p>
                <br/>
                <u>Invariants</u>
                <p>Invariants restrict values further. In the case of Datec, we would need to 
                    specify that the day can only be 366 if the year is a leap year, and as 
                    such:<br/>
                    $\textit{Datec}::\textit{day}:\lbrace1,...,366\rbrace$<br/>
                    $\textit{year}:\mathbb{N}$<br/>
                    $\textit{inv}(\textit{mk-Datec}(d,y))\triangle y \textit{mod} 4=0\vee d\leq365$</p>
                <br/>
                <u>Example</u>
                <p><img src='Formal Specification/Image13.jpg' alt='Thirteenth Image' style='max-width: 100%;'></p>
                <br/>
                <u>Map Notation</u>
                <p>When variables, paramters or results are of a function type we usually call the 
                    function type a map. It is frequently the case that the domain of the map is 
                    finite.<br/>Map notation is defined by a value, then a $\mapsto$, and then 
                    another value. Each individual mapping is called a maplet. Maps can also be 
                    defined using comprehension.<br/>The domain operator of a map will retrieve 
                    the set of domain values of the map. This is defined by the reserved word 
                    dom.<br/>The range operator will retrieve the set of all the range values, 
                    noted by rng.<br/>The map override operator, defined by $\dagger$, will yield 
                    the union of maplets of two maps. If the domain is the same for two maplets in 
                    both the maps, the maplet of the right map will be used in the map override of 
                    the two. <br/>The restriction operator, defined by $\triangleleft$, which, 
                    when applied to a set and a map, it will output a map with only the domains 
                    that appear in the set.<br/>If D and R are two sets, the notation being an 
                    arrow from D to R with an m riding on top of it.<br/>So with,<br/>
                    <img src='Formal Specification/Image14.jpg' alt='Fourteenth Image' style='max-width: 100%;'><br/>
                    You would get a set of sets with all mapping possibilities, so:<br/>
                    $\lbrace\lbrace \rbrace,\lbrace a\mapsto1\rbrace,\lbrace a\mapsto2,\lbrace b\mapsto1\rbrace,\lbrace b\mapsto2\rbrace,\lbrace a\mapsto1,b\mapsto1\rbrace$$,\lbrace a\mapsto1,b\mapsto2\rbrace,\lbrace a\mapsto2,b\mapsto1\rbrace,\lbrace a\mapsto2,b\mapsto2\rbrace\rbrace$
                    A very complex example of a mapping includes banking:<br/>
                    <img src='Formal Specification/Image15.jpg' alt='Fifteenth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image16.jpg' alt='Sixteenth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image17.jpg' alt='Seventeenth Image' style='max-width: 100%;'></p>
                <br/>
                <u>Natural Deduction</u>
                <p>In section 2, we proved the formula<br/>
                    <img src='Formal Specification/Image18.jpg' alt='Eighteenth Image' style='max-width: 100%;'><br/>
                    True<br/>We deduced that the formula<br/>
                    <img src='Formal Specification/Image19.jpg' alt='Nineteenth Image' style='max-width: 100%;'><br/>
                    The way we proved these formulae was through a process called rigorous proof. 
                    Rigorous proof is prone to human error so an alternative proofing method must 
                    be chosen that a computer would be able to check through. Such a proof method 
                    is called formal proof.</p>
                <br/>
                <u>Sequents</u>
                <p>When all the hypotheses in a list of formulae are true, a sequent would govern 
                    that another formula would be therefore true, and the notation for this is as 
                    such<br/>
                    $\Gamma\vdash E$<br/>
                    This statement states that if all the formulae in the list of formulae known 
                    as the hypotheses $(\Gamma)$ are true, then the formula, E is true.<br/>The $\vdash$
                    is called a turnstile and the whole statement of $\Gamma\vdash E$ is the sequent.<br/>
                    If E is a proof obligation, in order to prove E true, we need to generate the 
                    sequent<br/>
                    $\vdash E$<br/>
                    Which has no hypotheses. To complete the proof, we must generate sequents 
                    either using inference rules or truth tables. In the case of truth tables, the 
                    same symbol is used but with two horizontal lines rather than one.<br/>
                    $E_1, E_2 \vee E_3 |= E_1 \wedge E_2 \vee E_1 \wedge E_3$ truth table:<br/>
                    <img src='Formal Specification/Image20.jpg' alt='Twentieth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image21.jpg' alt='Twenty First Image' style='max-width: 100%;'><br/>
                    Where $E_1$ and $E_2 \vee E_3$ are both true, the formula can be satisfied, 
                    therefore this sequent is true according to the truth table.<br/>Generating 
                    sequents that can contain infinite possibilities will require inference rules 
                    to be used to add boundaries to the number of true sequents and formulae that 
                    can be inferred to tell if other formulae or sequents are true.<br/>Consider 
                    $\frac{E_1}{E_1 \vee E_2}$<br/>
                    In this case, $E_1$ is the only hypothesis of the inference rule and $E_1 \vee E_2$
                    is the consequent. This means that if $E_1$ is in the list of true inference 
                    rules, then $E_1 \vee E_2$ can be inserted into the inference rules where $E_2$ 
                    can be any formula. $E_1 \vdash E_1 \vee E_2$ can also be inserted into the 
                    inference rules as a sequent.<br/>These inference rules do not assume 
                    commutative consequents. This means that $E_2 \vee E_1$ can not be put in the 
                    inference rules until a new inference rule of $\frac{E_1}{E_2 \vee E_1}$ has 
                    been created.<br/>Several hypotheses in an inference rule are separated by a 
                    semi-colon. In some inference rules, sequents are implemented in the 
                    hypotheses of the inference rule. If a sequent in a hypothesis has multiple 
                    hypotheses itself, then these hypotheses are separated by commas. If an 
                    inference rule has an -I addition, this means that operators are included in 
                    the consequent where they are not in the hypotheses. Generally, visually, an 
                    -I inference rule has a larger looking denominator. The -E addition deals with 
                    the elimination of operators in the consequent of an inference rule. This 
                    would visually make the denominator appear smaller.<br/>There are inference 
                    rules that can also define the propositional operators in terms of $\wedge$ or 
                    $\lnot$. $\textit{Defn}-\wedge$ can set the consequent or hypotheses to have 
                    their propositional operators to $\wedge$. $\textit{Defn}-\lnot$ can set the 
                    consequent or hypotheses to have their propositional operators to $\lnot$.<br/>
                    A very strange inference rule is the contradiction rule, notate by: 
                    $\frac{E_1; \lnot E_1}{E_2}$ where $E_2$ is any formula. The hypotheses state 
                    that if the boolean value of $E_1$ and $\lnot E_1$ are both true, the new 
                    formula can be implemented into the inference rules.<br/>Prove 
                    $E_1 \vee E_2 \vdash E_2 \vee E_1$<br/>
                    Visually, this sequent is obviously true as we know that the or statement is 
                    commutative, however, the proof has to be shown using inference rules.<br/>
                    If $E_1 \vee E_2$ is true, as well as $E_1 \vdash E_2 \vee E_1$ and 
                    $E_2 \vdash E_2 \vee E_1$, then $E_2 \vee E_1$ can be put in the inference 
                    rules.</p>
                <br/>
                <u>Propositional Inference Rules</u>
                <p><img src='Formal Specification/Image22.jpg' alt='Twenty Second Image' style='max-width: 100%;'><br/>
                    Deduces that one of the formulae in the consequent below is going to be true, 
                    and as all the formulae in the consequent are ORed onto one another, then the 
                    overall consequent is true.<br/>
                    <img src='Formal Specification/Image23.jpg' alt='Twenty Third Image' style='max-width: 100%;'><br/>
                    Deduces that all of the formulae in the first hypothesis are true, meaning 
                    that all the following sequents in the hypotheses are also true and thus the 
                    formula E can be placed in the hypotheses.<br/>
                    <img src='Formal Specification/Image24.jpg' alt='Twenty Fourth Image' style='max-width: 100%;'><br/>
                    If all of the standard values of the formulae in the hypotheses are false to 
                    be true when they're NOTed, then the standard, ORed statement of all the 
                    formulae will be false, but if that statement is NOTed as well, then it can be 
                    the consequent and then placed in the hypotheses.<br/>
                    <img src='Formal Specification/Image25.jpg' alt='Twenty Fifth Image' style='max-width: 100%;'><br/>
                    In this case, if all the formulae in the inference rule are false, and the 
                    overall statement is NOTed to make the statement true, this means that any 
                    formula from that statement, individually NOTed, will be a true consequent 
                    and can be placed in the inference rules.<br/>
                    <img src='Formal Specification/Image26.jpg' alt='Twenty Sixth Image' style='max-width: 100%;'><br/>
                    This is a simple De Morgan's deduction, where the formula in the hypothesis is 
                    true, a double NOTed equivalent of that formula will also be true. The same 
                    goes for the similar but essentially opposite elimination rule:<br/>
                    <img src='Formal Specification/Image27.jpg' alt='Twenty Seventh Image' style='max-width: 100%;'><br/>
                    If the inference rule contains multiple hypotheses they are to be separated 
                    using semi-colons.<br/>Multiple hypotheses within a sequent are separated by 
                    commas, where that sequent is in the hypotheses of an inference rule.<br/>The 
                    I stands for introduction (of operators) and the E stands for elimination (of 
                    operators).<br/>Also, there are propositional rules for some other, defined 
                    inference rules.<br/>
                    <img src='Formal Specification/Image28.jpg' alt='Twenty Eighth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image29.jpg' alt='Twenty Ninth Image' style='max-width: 100%;'><br/>
                    The last inference rule is saying that if a formula and its NOTed version are 
                    both true, then any other formula is also true.</p>
                <br/>
                <u>Layout of Proofs</u>
                <p>Inference rules can sometimes have sequents in their hypotheses, making the 
                    proof styling a form of natural deduction. Natural deduction proofs can be 
                    written and indented in a 'block-structured' way.<br/>
                    <img src='Formal Specification/Image30.jpg' alt='Thirtieth Image' style='max-width: 100%;'></p>
                <br/>
                <u>Derived Rules</u>
                <p>Because we have proved $E_1\vee E_2\vdash E_2\vee E_1$, we can say that we have 
                    derived the inference rule:<br/>
                    $\frac{E_1\vee E_2}{E_2\vee E_1}$<br/>
                    It's a good idea to build up a reserve of derived inference rules to help with 
                    the overall proof.<br/>
                    <img src='Formal Specification/Image31.jpg' alt='Thirty First Image' style='max-width: 100%;'><br/>
                    For all of the hypotheses rules to be true, the ANDed consequent statement of 
                    all the formulae must also be true.<br/>
                    <img src='Formal Specification/Image32.jpg' alt='Thirty Second Image' style='max-width: 100%;'><br/>
                    For the hypothesis to be true, all of the formulae need to be true, and as 
                    such, any singular formula can be the consequent.<br/>
                    <img src='Formal Specification/Image33.jpg' alt='Thirty Third Image' style='max-width: 100%;'><br/>
                    For the hypothesis to be true, the formula must be false and as such, the 
                    ANDed and then NOTed combination of all the possible formulae will always be 
                    true and thus can be the consequent.<br/>
                    <img src='Formal Specification/Image34.jpg' alt='Thirty Fourth Image' style='max-width: 100%;'><br/>
                    For the hypotheses to be true, all the formulae must be false, and as such, E 
                    can then be true as the consequent.</p>
                <br/>
                <u>Predicate Logic Inference Rules</u>
                <p>This is for logic based on quantifiers.<br/>
                    <img src='Formal Specification/Image35.jpg' alt='Thirty Fifth Image' style='max-width: 100%;'><br/>
                    This means that for s in the set X, and s being used in place of x in the 
                    formula E, then, for some of x in the set X, the formula using x will also be 
                    true.<br/>
                    <img src='Formal Specification/Image36.jpg' alt='Thirty Sixth Image' style='max-width: 100%;'><br/>
                    This means that for some of x in X, the formula of E using x is true, and y is 
                    in x, as well as the same formula with y in place of x being used infers that 
                    another formula is true. Both of these situations being true, the other formula 
                    would be the consequent.<br/>
                    <img src='Formal Specification/Image37.jpg' alt='Thirty Seventh Image' style='max-width: 100%;'><br/>
                    This means that for x in the set of X, it infers that the formula using x is 
                    false, and thus the NOTed version is inferred. This would mean that some 
                    values of x are not in X but the formula still holds for x.<br/>
                    <img src='Formal Specification/Image38.jpg' alt='Thirty Eighth Image' style='max-width: 100%;'><br/>
                    This means that for some of the values that aren't in the set X, the formula 
                    using x still holds. Also, s is in the set X. This means that using s in place 
                    of x for the formula will not hold and the overall statement for the 
                    consequent will have to be NOTed to be true.<br/>
                    <img src='Formal Specification/Image39.jpg' alt='Thirty Ninth Image' style='max-width: 100%;'><br/>
                    The left hand inference rule means that for some values of x that aren't in 
                    the set X, the formula will not hold using x and this means that for all 
                    values of x in the set X, the formula holds for x. It is the opposite for the 
                    other inference rule.<br/>
                    <img src='Formal Specification/Image40.jpg' alt='Fourtieth Image' style='max-width: 100%;'><br/>
                    This means that from x being in the set X, we can infer that the formula holds 
                    for X, and this means that for all values of x in X, the formula will hold.<br/>
                    <img src='Formal Specification/Image41.jpg' alt='Fourty First Image' style='max-width: 100%;'><br/>
                    This means that for all x in the set X, the formula holds for x. Also, s is in 
                    the set X. If both of these hypotheses are true, then the formula using s in 
                    place of x.</p>
                <br/>
                <u>Special Rules for Predicate Logic</u>
                <p>If a variable x has not been used yet and the set X is not empty, then the 
                    rule<br/>
                    <img src='Formal Specification/Image42.jpg' alt='Fourty Second Image' style='max-width: 100%;'><br/>
                    Is true and can be used to introduce x.<br/>
                    <img src='Formal Specification/Image43.jpg' alt='Fourty Third Image' style='max-width: 100%;'><br/>
                    This inference rule can be used to replace the value of one variable with 
                    another assuming that both values are equal.</p>
                <br/>
                <u>Induction</u>
                <p>In order to carry out proofs involving recursive function definitions, we need 
                    the following induction inference rule<br/>
                    <img src='Formal Specification/Image44.jpg' alt='Fourty Fourth Image' style='max-width: 100%;'><br/>
                    This inference rule is used for induction, showing that using 0 in place of n 
                    in the formula p will output true, n is a natural number and using n in 
                    formula p will infer that using n+1 in formula p will also be true. 
                    Considering this, from n being a natural number, we can infer that using n in 
                    p will hold.<br/>
                    <img src='Formal Specification/Image45.jpg' alt='Fourty Fifth Image' style='max-width: 100%;'><br/>
                    <img src='Formal Specification/Image46.jpg' alt='Fourty Sixth Image' style='max-width: 100%;'></p>
            </div>
        </div>
    </body>
</html>