<html>
    <head>
        <title>2D Computer Graphics</title>
        <link rel="stylesheet" href="Main.css">
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    </head>
    <body>
        <div class="Main-Div">
            <a name="Top"></a>
            <h1>Tom & Loughborough University - 2D Computer Graphics</h1>
            <div id="Back-Button-Div">
                <input type="button" class="Back Button" onclick="window.location = 'UniversityModules.html';" value="Back to University Modules">
                <input type="button" class="Back Button" onclick="window.location = '#Top';" value="Back to Top">
            </div>
            <br/>
            <div class="Sub-Div">
                <u>Raster Fundamentals</u>
                <p>A raster display shows a matrix with a series of pixels in it that make up a 
                    virtual image. The image is refreshed one row at a time from top to bottom. In a 
                    visual representation, a raster matrix would show a series of 0's and 1's neatly 
                    aligned. The 0's would be blank space in the virtual image and the 1's will 
                    represent the lit up pixels that show the virtual image. In the simplest raster 
                    display, one bit would represent one pixel but in more complicated raster 
                    displays, more than one bit would represent a pixel.<br/>On a refresh of a raster 
                    display, there are aspects to the resolution. One example would be the limited 
                    spatial resolution. This is where there are not enough pixels to resolve a good 
                    quality line/image. An example of this would be the jagged looking lines you can 
                    sometimes see in images on a virtual device. This is where there are not enough 
                    pixels in the resolution to display a perfect representation of what needs to be 
                    displayed. Another aspect is the intensity resolution. In the simple system 
                    mentioned before, there are two states for a pixel; on or off. This will, again 
                    not display the perfect representation of the image as the intensity of the 
                    pixel cannot be managed analogously. If a pixel has n bits associated with it 
                    then the intensity resolution will be 2<sup>n</sup>. To achieve these higher levels of 
                    intensity resolution, a multi-plane buffer can be utilized to display each bit 
                    representation of a pixel on each plane. Another aspect of resolution is 
                    temporal resolution which is the resolution of a virtual image with regards to 
                    the flow of time. This would be measured in frames per second (FPS).<br/>A 
                    monochrome display with 8 bits per pixel resolves 2<sup>8</sup> = 256 levels of grey-scale 
                    for the virtual image.</p>
                <br/>
                <u>Display Types</u>
                <p>Colours are achieved on a raster display by combining the intensity of three 
                    different colours, red green and blue, (in the RGB model). CRT and LCD (Liquid 
                    Crystal Display) both use the RGB model to generate a gamut of colours. The CRT 
                    tube has three RGB-emitting phosphors that are each energized by individual 
                    electron guns. An LCD is a liquid panel that is backlit with bright fluorescent 
                    light. Each pixel in an LCD display contains three sub-pixels that contain an 
                    intensity of red, green and blue each. Each sub-pixel is then opened or closed 
                    to emit a certain intensity of that colour which, when combined with the other 
                    two sub-pixels, will produce ‘any’ colour. In reality, the colour system is 
                    different from the virtual colour system. Printers for example use the CMYK 
                    model (Cyan, magenta, yellow and key (black)).</p>
                <br/>
                <u>Direct & Table-Driven Colour Displays</u>
                <p>Direct drive displays produce the buffer contents using 2n fixed colours for the 
                    nth buffer plane. This method of colour display is fine when there is enough 
                    memory to produce this number of possible pixel states and benefits from a high 
                    number of simultaneously displayable colours. For a 3-bit per pixel direct 
                    system, there isn’t a large enough range of colours for most applications to be 
                    able to use it. Full-colour is generally defined as a 24-bits per pixel 
                    intensity. This allows for 224 different colours to be simultaneously 
                    displayable. A device with a screen resolution of 1024x1024 will require 3 
                    megabytes of memory for the frame buffer.<br/>24/3 = 8, 2<sup>n</sup>=8, n=3, therefore 3 
                    megabytes is the answer.<br/>Table driven displays are a better alternative 
                    when there is less memory available for the refresh buffer. The colour table is 
                    dynamic meaning that the 2<sup>n</sup> colours that are displayable in the image can be 
                    changed. The palette size of a colour display is determined by the number of 
                    bits addressing each gun. If m bits control each gun, the palette size is (2<sup>m</sup>)3 
                    or 2<sup>3m</sup>. From this, 2<sup>n</sup> can be displayed at any one time. Therefore, if m=4 and 
                    n=4 then the colours that can be selected at any one time is 2<sup>4</sup>=16 and the 
                    palette size is (2<sup>4</sup>)<sup>3</sup>=2<sup>12</sup>=4096. When m=4, the hexadecimal notation can be used 
                    to define the intensity of the colour guns. FFF will represent white and 000 
                    will represent black. A more typical table driven display would be when m=8 and 
                    n=8. This would produce 256 possible colours that can be displayed at any one 
                    time and 2<sup>24</sup> colours in the palette.</p>
                <br/>
                <u>Multiple Images in the Frame Buffer</u>
                <p>Rather than having n planes in a buffer, n can be recognized as n images in a 
                    buffer. Assuming the display is monochrome will help with understanding. An 
                    example would be loading the entries 0-3 as white and 4-7 as black. When this 
                    is done. All the image for the first image will be white and all the image of 
                    the last image will be black. The middle image will have aspects of black and 
                    white and therefore will be visible.<br/>
                    <img src='2D Computer Graphics/Image1.jpg' alt='First Image'><br/>
                    <img src="2D Computer Graphics/Image2.jpg" alt='Second Image'>
                    </p>
                <br/>
                <u>Display Lists & Picture Segmentation</u>
                <p><img src="2D Computer Graphics/Image3.jpg" alt='Third Image'><br/>
                   A display list can be segmented to produced segments of the display list. These 
                   segments can practically represent vectors of an image; different landmarks that 
                   would appear on the display.</p>
                <br/>
                <u>Raster System with Support for Picture Segmentation</u>
                <p>A raster system with support for picture segmentation will put the second 
                    segment at the bottom of the display list in free storage. When the image or 
                    segment needs to be changed, the segment will be converted to the second 
                    segment and that segment will be displayed as the pointer for the first segment 
                    will be dereferenced and released to free store.</p>
                <br/>
                <u>Operations on Segments</u>
                <p>Selective erasure is the condition where the user has segments of the display 
                    dereferenced and not refreshed, effectively removing that segment from the 
                    buffer. To update a segment, that segment must eventually get to the top of 
                    the display list at segment 1. Garbage collection will eventually be required 
                    when too many operations have been performed and the display list file has 
                    been broken up from all the operations and has too much space.</p>
                <br/>
                <u>Segment Formats</u>
                <p><img src="2D Computer Graphics/Image4.jpg" alt='Fourth Image'><br/>
                   To make a segment invisible, you must make the second name in the segment 
                   header equal the first name. To make that segment visible again, the first word 
                   in the header must be overwritten with an instruction to jump two words.</p>
                <br/>
                <u>Coordinate Systems</u>
                <p>The two-dimensional plane &#8477; is all the pairs of real numbers (x, y).</p>
                <br/>
                <u>Cartesian Coordinate System for &#8477;</u>
                <p><img src="2D Computer Graphics/Image5.jpg" alt='Fifth Image'><br/>
                   With Cartesian coordinates, the axes can point in either direction, and the 
                   positive integer of each value will always follow the arrow above the line of 
                   the other arrow. With the right-handed system, the y axis is 90 degrees 
                   anti-clockwise from the x axis and with the left-handed system, the y axis is 
                   90 degrees clockwise from the x axis. Left-hand systems are more natural for a 
                   computer display as the display is loaded from the top left to the bottom 
                   right. However, the commonly seen systems for humans are the right-hand 
                   systems.</p>
                <br/>
                <u>Polar Coordinate System for &#8477;</u>
                <p>With this system, instead of coordinating a point with an x value and a y 
                    value, the polar coordinate system will define a displacement from the 
                    origin, so a distance.<br/>
                    <img src="2D Computer Graphics/Image6.jpg" alt='Sixth Image'><br/>
                    At point P therefore in figure 3, the value of x will be r where <br/>
                    `r = sqrt(x^2 + y^2)`<br/>
                    The value of y will be &theta; where<br/>
                    `\theta = \tan^{-1}(\frac{y}{x})`<br/>
                    There can be a simple conversion from polar to Cartesian by doing the following<br/>
                    `x = r\cos\theta`<br/>
                    `y = r\sin\theta`</p>
                <br/>
                <u>Homogenous Coordinates for &#8477;<sup>2</sup></u>
                <p>An extra dimension is given to the initial pair from a Cartesian system making 
                    the concluding triplet (x, y, 1). Any triplet of real numbers (&lambda;x, &lambda;y, &lambda;) for 
                    &lambda; &ne; 0.</p>
                <br/>
                <u>The Plane &#8477;<sup>2</sup> as a Set of Vectors</u><br/>
                <u>Addition and Scalar Multiplication of Vectors in &Ropf;<sup>2</sup> - Algebraic View</u>
                <p>Pairs of points in &Ropf;<sup>2</sup> can be added together like so<br/>
                    `(x, y) + (x', y') = (x + x', y + y')`<br/>
                    Scalar multiplication of vectors can also be achieved with &lambda; like so<br/>
                    `\lambda(x, y) = (\lambdax, \lambday)`<br/>
                    When &lambda; = -1, vectors can be subtracted like so<br/>
                    `(x, y) - (x', y') = (x, y) + (-x', -y') = (x - x', y - y')`<br/>
                    (0, 0) is the zero vector. It satisfies that when it is added to another 
                    vector, the result is the other vector.</p>
                <br/>
                <u>Addition & Scalar Multiplication of Vectors in &Ropf;<sup>2</sup> - Geometric View</u>
                <p><img src="2D Computer Graphics/Image7.jpg" alt='Seventh Image'><br/>
                    </p>
                <br/>
                <u>The Standard Basis Vectors for the Two Dimensional Plane</u>
                <p>If there are two vectors in &Ropf;<sup>2</sup>, i and j where i=(1, 0) and j=(0, 1), then the 
                    two vectors can represent any vector in &Ropf;<sup>2</sup> with the help of &lambda; functions.<br/>
                    `r = (x, y) = x(1, 0) + y(0, 1) = xi + xj`<br/>
                    These are known as the standard basis vectors in &Ropf;<sup>2</sup>.<br/>
                    <img src="2D Computer Graphics/Image8.jpg" alt='Eighth Image'>
                    </p>
                <br/>
                <u>Magnitude & Direction of Vectors in &Ropf;<sup>2</sup></u>
                <p>`|| \(x, y)\ || = sqrt(x^2 + y^2)`<br/>
                    This represents the length of a vector or the distance from the origin.<br/>
                    <img src="2D Computer Graphics/Image9.jpg" alt='Ninth Image'><br/>
                    This graph represents the direction difference between two vectors, the 
                    difference in direction from r<sub>1</sub> to r<sub>2</sub> would be<br/>
                    `\theta = \theta_1 - \theta_2`<br/>
                    We have<br/>
                    `\cos\theta = \cos(\theta_2 - \theta_1) = \cos\theta_1\cos\theta_2 + \sin\theta_1\sin\theta_2`<br/>
                    Now<br/>
                    `\cos\theta_1 = \frac{x_1}{||r_1||}`<br/>
                    `\cos\theta_2 = \frac{x_2}{||r_2||}`<br/>
                    `\sin\theta_1 = \frac{y_1}{||r_1||}`<br/>
                    `\sin\theta_2 = \frac{y_2}{||r_2||}`<br/>
                    Then<br/>
                    `\cos\theta = \frac{x_1x_2+y_1y_2}{||r_1||||r_2||}`<br/>
                    Therefore, noting the `x_1x_2 + y_1y_2` part of the last equation, this can be used to 
                    determine the scalar product of any two vectors. As such, it is defined by 
                    `r_1 \cdot r_2 = x_1 x_2 + y_1y_2`.<br/>
                    Length in scalar products is simply<br/>
                    `||r|| = sqrt(r \cdot r)`<br/>
                    Direction of the scalar product is<br/>
                    `\cos\theta = \frac{r_1 \cdot r_2}{||r_1||||r_2||}` or `||r_1||||r_2||\cos\theta = r_1 \cdot r_2`<br/>
                    If r has length 1 or `||r|| = r \cdot r = 1` then r is a unit vector.<br/>
                    Two vectors are orthogonal if their direction difference is `\theta = \frac \pi2`.<br/>
                    Two vectors are parallel if the angle between them equals zero.<br/>
                    Orthogonality Test - Vectors are said to be orthogonal if and only if `a \cdot b = 0` as<br/>
                    `a \cdot b = ||a||||b||\cos\theta`<br/>
                    And if `a \cdot b = 0` then that implies that `\cos\theta = 0` which would mean that `\theta = \frac \pi2`.<br/>
                    Parallelism Test - Vectors are parallel if and only if the angle between them is equal to `\pi` or 0.</p>
                <br/>
                <u>Square Matrices</u><br/>
                <u>Addition and Scalar Multiplication of Square Matrices</u>
                <p>A 2x2 matrix is a simple square matrix to base learning off of. It has two rows 
                    and two columns culminating in a total of 4 values in each corner of the 
                    matrix.<br/> Adding two matrices is simple so long as the matrices are the 
                    same size in dimension. It will simply result in a 2x2 matrix with the values 
                    being the added values of the operand matrices.<br/>
                    So $\left\lgroup\begin{matrix}1 & 2\cr3 & 4\end{matrix}\right\rgroup + \left\lgroup\begin{matrix}5 & 6\cr7 & 8\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}6 & 8\cr10 & 12\end{matrix}\right\rgroup$<br/>
                    And $\lambda\left\lgroup\begin{matrix}a & b\cr c & d\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}\lambda a & \lambda b\cr\lambda c & \lambda d\end{matrix}\right\rgroup$<br/>
                    Using the same principles as geometric subtraction of two vectors, by scalar multiplying with 
                    `\lambda = -1`, two matrices can be subtracted.<br/>A 2x2 zero matrix is a 2x2 matrix 
                    where all the values are 0. It is NOT a matrix with no values. This matrix can 
                    be added to any other 2x2 matrix to culminate in the other 2x2 matrix.<br/>
                    Matrix addition is commutative and associative.</p>
                <br/>
                <u>Alternative Notation</u>
                <p>Matrices are often notated as such<br/>
                    $A = \left\lgroup\begin{matrix}a_{11} & b_{12}\cr c_{21} & d_{22}\end{matrix}\right\rgroup$<br/>
                    This makes it easier to multiply larger matrices.<br/>`A = {a_{ij}}` is a 
                    common notation. The index i is the row index and j is the column index. With 
                    the addition of two matrices, individual value addition can be noted down from 
                    these expressions.<br/>
                    `C = B + A`<br/>
                    `c_{ij} = b_{ij} + a_{ij}`</p>
                <br/>
                <u>Multiplication of Square Matrices</u>
                <p>$B = \left\lgroup\begin{matrix}b_{11} & b_{12}\cr b_{21} & b_{22}\end{matrix}\right\rgroup$<br/>
                    $C = \left\lgroup\begin{matrix}c_{11} & c_{12}\cr c_{21} & c_{22}\end{matrix}\right\rgroup$<br/>
                    $B \cdot C = \left\lgroup\begin{matrix}b_{11}c_{12} + b_{21}c_{11} & b_{11}c_{12} + b_{12}c_{22}\cr b_{21}c_{11} + b_{22}c_{21} & b_{21}c_{12} + b_{22}c_{22}\end{matrix}\right\rgroup$<br/>
                    `d_{11} = (b_{11}b_{12}) \cdot (c_{11}c_{21}) = (b_{11}c_{11} + b_{12}c_{21})`<br/>
                    or<br/>
                    `d_{ij} = \sum_{k = 1}^2(b_ic_k + b_kc_j)`<br/>
                    Matrices can be inverted<br/>
                    $\left\lgroup\begin{matrix}3 & 0\cr 0 & -\frac 32\end{matrix}\right\rgroup \cdot \left\lgroup\begin{matrix}\frac 13 & 0\cr 0 & -\frac 23\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}1 & 0\cr 0 & 1\end{matrix}\right\rgroup$<br/>
                    $\left\lgroup\begin{matrix}3 & 3\cr -1 & -1\end{matrix}\right\rgroup$ has no inverse.<br/>
                    `A^T` is the transpose of A that has A's columns as rows and A's rows as columns.<br/>
                    In this case<br/>
                    $\left\lgroup\begin{matrix}2 & 1\cr 4 & 3\end{matrix}\right\rgroup$ has a transpose of $\left\lgroup\begin{matrix}2 & 4\cr 1 & 3\end{matrix}\right\rgroup$ where the top right and bottom left values are switched.<br/>
                    If `A^T = A` then the matrix is symmetric.</p>
                <br/>
                <u>Transformation of the Plane</u>
                <p>In a display, there are multiple functionalities to map objects in a display. 
                    These transformations could occur as rotations, translations and scalings.<br/>
                    The simple function `T:\mathbb{R}^2 \rightarrow \mathbb{R}^2` is the mapping of an object from one point in the 
                    plane to another point on the plane.<br/> `Tr=3r+a` is the vector form of a 
                    transformation.<br/> `T(x, y) = 3(x, y)+(a_1, a_2)` is the coordinate form of 
                    the transformation.<br/>
                    To tell if a transformation is linear or not, the transformations have to be 
                    as such<br/>
                    `T(r_1, r_2) = Tr_1 + Tr_2` and `T(\lambda r) = \lambda Tr` where `\lambda \in \mathbb{R}` and `r_1, r_2, r \in \mathbb{R}^2`<br/>
                    `T(x, y) = (2x + y, 4y)`<br/>
                    So `T(r_1 + r_2)` where $r_1 = \left\lgroup\begin{matrix}1\cr3\end{matrix}\right\rgroup$ and $r_2 = \left\lgroup\begin{matrix}5\cr7\end{matrix}\right\rgroup$<br/>
                    Is it linear?<br/>
                    `2x + 2 + 4y - 1 = 2x + 4y + 1`<br/>
                    This is the result of both `T(x + y)` and `Tx + Ty` respectively.<br/>
                    `2x` translates to `2(2x + 2)` and `2y` translates to<br/>
                    $T(r_1 + r_2) = T\left\lgroup\begin{matrix}6\cr10\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}22\cr40\end{matrix}\right\rgroup$<br/>
                    $T(r_1) = T\left\lgroup\begin{matrix}1\cr3\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}5\cr12\end{matrix}\right\rgroup$ and $T(r_2) = T\left\lgroup\begin{matrix}5\cr7\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}17\cr28\end{matrix}\right\rgroup$ and $T(r_1) + T(r_2) = \left\lgroup\begin{matrix}22\cr40\end{matrix}\right\rgroup$<br/>
                    $T(\lambda r) = \lambda Tr$ so $r = r_1 = \left\lgroup\begin{matrix}1\cr3\end{matrix}\right\rgroup$ and `\lambda = 3`<br/>
                    $T(\lambda r) = T\left\lgroup\begin{matrix}3\cr9\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}15\cr36\end{matrix}\right\rgroup$ and $\lambda Tr = T\left\lgroup\begin{matrix}1\cr3\end{matrix}\right\rgroup = \lambda\left\lgroup\begin{matrix}5\cr12\end{matrix}\right\rgroup = \left\lgroup\begin{matrix}15\cr36\end{matrix}\right\rgroup$<br/>
                    Therefore `T(x, y) = (2x + y, 4y)` is a linear transformation.</p>
                <br/>
                <u>Matrix Transformations</u>
                <p>A transformation in a 2x2 matrix will produce values as such<br/>
                    $\left\lgroup\matrix{a & b\cr c & d}\right\rgroup\left\lgroup\matrix{x\cr y}\right\rgroup = \left\lgroup\matrix{ax & by\cr cx & dy}\right\rgroup$<br/>
                    The first column represents the x values and the second column represents the y values.<br/>
                    The identity transformation `I(x, y) = (x, y)` can be used to find linear 
                    transformations and corresponds to the identity matrix that has been covered.</p>
                <br/>
                <u>Scale Transformations</u>
                <p>`S(x, y) = (\lambda x, \mu y)` where `\lambda > 0` and `\mu > 0`<br/>
                    This function describes scale transformations. This is where the object's size 
                    is altered by either increasing or decreasing the size of the object from the 
                    origin.<br/>
                    $\left\lgroup\matrix{\lambda & 0\cr 0 & \mu}\right\rgroup\left\lgroup\matrix{x\cr y}\right\rgroup = \left\lgroup\matrix{\lambda x\cr \mu y}\right\rgroup$<br/>
                    Scalar transformations are all linear and invertible, meaning that you can 
                    double the size of an object and halve the size of an object.<br/>
                    $S^{-1} = \left\lgroup\matrix{\frac 1\lambda & 0\cr 0 & \frac 1\mu}\right\rgroup$<br/>
                    The appropriate equation for the inverse of a scalar is as shown above.<br/>
                    Scalar transformations must ALWAYS take place where one of the vertices is on 
                    the origin.</p>
                <br/>
                <u>Rotation Transformations</u>
                <p>Rotation transformations are also linear. The rotations do take place around 
                    the origin and the ones that don't are said to be length preserving.<br/>The 
                    lengths of the vectors of the object being rotated will remain the same in a 
                    rotation transformation. The angle from x will change, (as will the angle from 
                    y).<br/>If<br/>
                    `r = (x, y)` and `r' = (x', y')`<br/>
                    Then<br/>
                    `x = r\cos\phi` and `y = r\sin\phi`<br/>
                    `x' = r\cos(\theta + \phi)` and `y' = r\sin(\theta + \phi)`<br/>
                    And<br/>
                    `\cos(\theta + \phi) = \cos\theta\cos\phi - \sin\theta\sin\phi`<br/>
                    `\sin(\theta + \phi) = \sin\theta\cos\phi + \cos\theta\sin\phi`<br/>
                    We obtain<br/>
                    `x' = r(\cos\theta\cos\phi - \sin\theta\sin\phi) = x\cos\theta - y\sin\theta`<br/>
                    And<br/>
                    `y' = r(\sin\theta\cos\phi + \cos\theta\sin\phi) = x\sin\theta + y\cos\theta`<br/>
                    Therefore<br/>
                    `W(x, y) = (x\cos\theta - y\sin\theta, x\sin\theta + y\cos\theta)`<br/>
                    This can be written in matrix form:<br/>
                    $\left\lgroup\matrix{\cos\theta & -\sin\theta\cr \sin\theta & \cos\theta}\right\rgroup\left\lgroup\matrix{x\cr y}\right\rgroup = \left\lgroup\matrix{x\cos\theta - y\sin\theta\cr x\sin\theta + y\cos\theta}\right\rgroup$</p>
                <br/>
                <u>Translation Transformations</u>
                <p>Translation is the method of moving an object in space without rotation or 
                    scaling.<br/>In the vector form, translations can be written as:<br/>
                    `T_r = r + r_0`<br/>
                    Or in component form:<br/>
                    `T(x, y) = (x + x_0, y + y_0)`<br/>
                    The translation `T_r = r - r_0` is the inverse of the translation `T_r = r + r_0`</p>
                <br/>
                <u>Combining Transformations</u>
                <p>Multiple transformations have to be combined in the right order because 
                    different orders will achieve different looking objects, especially with 
                    scalar transformations combined with rotation transformations while the object 
                    is at the origin. Uniform scalar transformations where lambda=mu are commutable 
                    with rotation transformations.<br/>Rotation or scalar with translation 
                    transformations are both not commutable as well.</p>
                <br/>
                <u>Inverse Tranformations</u>
                <p>Inverse transformations simply divide where you multiply and subtract where you 
                    add. They get the reverse action of what was just accomplished by the original 
                    transformation.</p>
                <br/>
                <u>Homogenous Representation of Transformations</u>
                <p>Translation transformations are non-linear, therefore they can't be represented 
                    in a 2x2 matrix. Homogenous form solves this issue by transforming the 2x2 
                    matrix into a 3x3 matrix. The top two values of the right-most column in the 
                    matrix will be the transformation values for x and y respectively. The bottom 
                    right matrix value is 1 and the bottom two values at the left are set at 0.<br/>
                    The inverse transformation in homogenous form will simply multiply the two 
                    translation values by -1, inversing there positivity to negativity and vice 
                    versa.<br/>As the multiplication of 2x2 matrices with 3x3 matrices cannot be 
                    accomplished, the 2x2 matrices for rotation and scalar transformations have to 
                    be embedded to become 3x3 matrices. The difference of these two transformation 
                    types in homogenous form from the translation in homogenous form is that these 
                    values at the right most column at the top are set to 0 instead.</p>
                <br/>
                <u>Application of Transformations in Computer Graphics</u>
                <p>In computer graphics, transformations are used for modelling and viewing in any 
                    software illustrating program or otherwise.</p>
                <br/>
                <u>Modelling Applications</u>
                <p>Constructive Geometry Modelling - Models have to be built from a library of 
                    primitive graphical models, their geometric transformations and Boolean set 
                    operators.<br/>Hierarchical Models and Combined Transformations for 
                    Dynamic/Animated Sequences - This model will break down a model into several 
                    different aspects that will all branch from one another if they are in any way 
                    connected.</p>
                <br/>
                <u>Circular List & Hierarchical Representations</u>
                <p>Trees tend to be a far better form of showing the hierarchical properties of an 
                    object than linked lists and can be explored and traversed quite easily. The 
                    form of a tree graph also denotes inheritance of parts of the model, from big 
                    parts that contain most of the other parts to the smallest end parts. All 
                    these parts will move accordingly from their parent objects.</p>
                <br/>
                <u>The Representations of Geometric Primitives</u><br/>
                <u>Explicit, Implicit & Parametric Forms</u>
                <p>Good geometric primitives like the circle or a straight line will all require a 
                    data structure associated with it and its neighbouring geometric pieces. Other 
                    processes will have to be called to be able to model these objects from the 
                    geometric primitives like finding the nearest line to the cursor position, 
                    determining if a point is inside a circle, determining if  a point is on a 
                    line. It also determines whether the cursor is in a polygon.<br/>Explicit 
                    Representation - `y = f(x)`<br/>Implicit Representation - `g(x, y) = 0`<br/>
                    Parametric Representation - `x = p(t), y = q(t)` or `r(t) = (p(t), q(t))`</p>
                <br/>
                <u>The Straight Line & the Circle</u><br/>
                <u>The Straight Line</u>
                <p>Explicit - `y = mx + c`<br/>This is for an infinitely long line where m is the 
                    gradient along x and c is the intercept.<br/>Finitely long lines are defined 
                    with - `y = mx + c, x_0 \le x \le x_1`<br/>
                    `m = \frac {y_1 - y_0}{x_1 - x_0}`<br/>
                    `c = y_1 - mx_1`<br/>
                    The equation may be written as:<br/>
                    `y = \frac {y_1 - y_0}{x_1 - x_0} + (y_1 - \frac{x_1y_1 - x_1y_0}{x_1 - y_0}) = `<br/>`\frac{y_1 - y_0}{x_1 - x_0} + \frac{y_1(x_1 - x_0) - (x_1y_1 - x_1y_0)}{x_1 - x_0} = y_1 - (x_1y_1 - x_1y_0)`<br/>
                    The problem with explicit form is that the representation is incomplete; 
                    vertical lines cannot be produced from explicit form.<br/>Implicit - `ax + by + c = 0`<br/>
                    This application deals with all cases involved in composing a straight line of 
                    finite length. The values a, b and c are all scalar to the x, y and intercept 
                    values. There will also be a pair of points `(x_0, x_1)` and `(y_0, y_1)` as 
                    coordinates of the line.<br/>Implicit representation is useful to test the 
                    points from a line in a plane.<br/>Point classification tests are created in 
                    this instance to test if a point is on a line or on either side of the line.<br/>
                    Parametric - `r(t) = r_0 + tu` for `-\infty < t < \infty`<br/>The infinite line needed to 
                    be found by a parametric equation will lie on the point r0 and it will be 
                    parallel to the vector u on the plane.<br/>
                    `x(t) = x_0 + tu_0`<br/>
                    `y(t) = y_0 + tu_1`<br/>
                    Where `u = (u_0, u_1)` is the vector of the line and t is the length from `r_0`.<br/>
                    The line can also be specified from two points in the line, `r_0, r_1`. Then 
                    the value u can be defined as:<br/>
                    `u = \frac{r_1 - r_0}{||r_1 - r_0||}`<br/>
                    Then the parametric form is used:<br/>
                    `r(t) = r_0 + t(r_1 - r_0)`<br/>
                    Applications of parametric form include the use of the DDA algorithm to create 
                    straight lines.</p>
                <br/>
                <u>The Circle</u>
                <p>Explicit - `y = y_c + sqrt(r^2 + (x − x_c)^2)`<br/>This equation has to be 
                    repeated once as each time covers one half of a circle.<br/>There are no known 
                    applications of the explicit representation.<br/>Implicit - `(y − y_c)^2 + (x − x_c)^2 − r^2 = 0`<br/>
                    If the circle representation is above 0, the point lies outside the circle, if 
                    the representation is below 0, the point lies inside the circle and if the 
                    representation is 0 then the point is on the line of the circle.<br/>
                    Parametric - `r(\theta) = (x_c + \cos\theta)i + (y_c + \sin\theta)j, 0 \le \theta \le 2\pi`<br/>
                    This is used as a platform for scan-conversion programs for the display of 
                    circles on a raster system.<br/>When a computation to find two objects 
                    intersecting at certain points, it is best to show one object like a circle in 
                    implicit form and one object like a straight line in parametric form to be able 
                    to tell at which two points the line crosses.</p>
                <br/>
                <u>Polygons</u>
                <p>A polygon is a collection of geometric primitives; a selection of vectors on a 
                    plane that all intersect to form a shape.</p>
                <br/>
                <u>Simple Data Structure for Polygons</u>
                <p>The data for vertices in a polygon are usually stored as (x, y) pairs. Edge 
                    information may be represented implicitly or explicitly. A chained table or 
                    flow chart can be used to illustrate the chronological order of the edges and 
                    their coordinates.<br/>Explicit representation is illustrated with two linked 
                    tables, an edge table and a vertex table. The edge table will store the vertex 
                    indices that lead to one another and the vertex table will still contain the x 
                    and y values for vertices.</p>
                <br/>
                <u>An Inside Test for Polygons</u>
                <p>If two diagonally opposite vertices of a rectangle R are given, the vertices 
                    are in R if and only if the x value of the top vertex is higher than that of 
                    the bottom vertex, and the same for y.<br/>For a polygon a point can be 
                    determined to be inside or outside a polygon by sending out a semi-infinite 
                    line in the x direction. If the number of times the line crosses the polygon 
                    is even, then the point lies outside of the polygon and if the number is odd, 
                    it lies inside the polygon.<br/>The extent of a polygon P is the smallest 
                    rectangle that surrounds the polygon. It is done by finding two points of the 
                    polygon with the highest and lowest pairs of x and y values. These two will 
                    become the bottom left and the top right vertices of the rectangle.<br/>Any 
                    point outside of the extent is outside of the polygon P, the ray test need 
                    only be applied to points that are in the extent of P. So long as the value of 
                    the point has an x value that is within the range of the minimum and maximum x 
                    values of the rectangle.</p>
                <br/>
                <u>Free-form Parametric Curves</u>
                <p>Not everything can be adequately represented with just circles, straight lines 
                    and polygons. In some cases, a Bezier Cubic curve will be used as a free-form 
                    shape function.<br/>The Bezier Cubic curve can be displayed in parametric form 
                    as so:<br/>
                    `r(t) = (1-t)^3r_0 + 3t(1-t)^2r_1 + 3t^2(1-t)r_2 + t^3r_3, 0 \le t \le 1`<br/>
                    The curve is essentially the same as the linked list to create a polygon, 
                    accept the four vectors are directing in a curved manner, (i.e. they change 
                    direction gradually and regularly).</p>
                <br/>
                <u>Producing Straight Lines</u>
                <p>On a raster display, only addressable points may be intensified and only when 
                    the line is 0, 45, or 90 degrees from the x-axis. If there are only two 
                    addressable points that a straight line passes through, then an algorithm will 
                    need to be constructed to produce the straight line.<br/>Lines  produced 
                    should appear straight, lines should have constant intensity along their 
                    length. For constant intensity, points should be placed at regular points on 
                    the line. Line intensity should also be independent of line length and 
                    inclination. This is difficult as for a horizontal straight line with k 
                    pixels, if there were a line `\frac \pi4`  from the initial line, the new line would 
                    have `\frac k{sqrt(2)}`  as the number of pixels on the line. The algorithm for creating the 
                    straight line must also be minimal in space and time complexity.</p>
                <br/>
                <u>The Simple Digital Differential Analyser for Generating Straight Lines</u>
                <p>If a line with endpoints `r_1 = (x_1, y_1)` and `r_2 = (x_2, y_2 )`, the vector 
                    equation for the line would be:<br/>
                    `r(t) = r_1 + t(r_2 - r_1)` where `0 \le t \le 1`<br/>
                    With two points, `r(t)` and `r(t + \epsilon)`, the length between them is 
                    equal to:<br/>
                    `r(t + \epsilon) - r(t) = \epsilon(r_2 - r_1)`<br/>
                    `r(t + \epsilon) = r(t) + \epsilon(r_2 - r_1)`<br/>
                    If we convert t to n to denote the nth pixel position and `t + \epsilon` as 
                    the n+1th pixel position, as well as changing r to the individual x and y 
                    values we will get:<br/>
                    `x(n + 1) = x(n) + \epsilon\delta x`<br/>
                    `y(n + 1) = y(n) + \epsilon\delta y`<br/>
                    The `\epsilon` value requires to be a small positive number and a relevant value is needed to achieve good line quality. The ϵ value determines the scale of the 
                    space between pixels and would need to be at least less than 1 to stop the algorithm from selecting just two pixel points from any line.<br/>With `\epsilon\delta x` and `\epsilon\delta y`
                    summing to +1 or -1, the scale will be appropriate enough that there won't be any holes in the straight line. If `\epsilon\delta y > \epsilon\delta x` then 
                    increment the pixel in the y-axis and otherwise increment the pixel in the x-axis.<br/>
                    `\epsilon = \frac 1{max{\delta x, \delta y}}`<br/>
                    If `\delta y > \delta x, \epsilon = \frac 1{\delta y}` and the recurrence relations are<br/>
                    `x(n + 1) = x(n) + \frac{\delta x}{\delta y}`<br/>
                    `y(n + 1) = y(n) + 1`<br/>
                    If `\delta x > \delta y, \epsilon = \frac 1{\delta x}` and the occurrence relations are<br/>
                    `x(n + 1) = x(n) + 1`<br/>
                    `y(n + 1) = y(n) + \frac{\delta x}{\delta y}`<br/>
                    In both cases, `\frac{\delta x}{\delta y}` will be less than or equal to 1.<br/>
                    <span style="color:red;">`Max Displacement = abs(x_2 - x_1);`<br/>
                        `If(abs(y_2-y_1) > \text{Max Displacement})`<br/>
                        `Then \text{Max Displacement} = abs(y_2 - y_1);`<br/>
                        `\text{Xinc} = \frac{abs(x_2 - x_1)}{\text{Max Displacement}};`<br/>
                        `\text{Yinc} = \frac{abs(y_2 - y_1)}{\text{Max Displacement}};`<br/>
                        `x = x_1 + 0.5;`<br/>
                        `y = y_1 + 0.5;`<br/>
                        `For(i = 0 to i = \text{Max Displacement}, i++)`<br/>
                        `Do Write Pixel(floor(x), floor(y), value);`<br/>
                        `x = x + \text{Xinc};`<br/>
                    `y = y + \text{Yinc};`</span></p>
                <br/>
                <u>Bresenhem's Algorithm for the Straight Line</u>
                <p>Bresenham's algorithm, unlike the DDA algorithm, will only use integer values and doesn't require division.<br/>The first step of Bresenham's algorithm is to 
                    analyse both the endpoints. Assuming that `r_1 = (X1, Y1)` is closer to the origin, and if it isn't then reverse the role of `r_2 = (X2, Y2)` with `r_1`. 
                    Translate the line by (-X1, -Y1) so that it begins at the origin. The origin is now joined with the difference in x and y from the endpoints of the line. This 
                    will result in no loss of generality until the assumption made that the slope of the line is between 0 and 1. The translated line now has the equation `y = \frac{\delta x}{\delta y}(x)`<br/>
                    The value `d_i` in the algorithm will be the decision variable that determines what crossed coordinate the lit pixel will lie on. If di is less than 0.5 on one 
                    side, then that point it is closer to will be the lit pixel. The point crossing the line with the x-axis of `x_i`, A, is denoted by<br/>
                    `(1 + x_i, \frac{\delta x}{\delta y}(1 + x_{i - 1}))`<br/>
                    As `y = \frac{\delta x}{\delta y}(x)`<br/>
                    <span style='color:red;'>`\text{Light Pixel} X1, Y1;`<br/>
                        `x = X1;`<br/>
                        `\text{Initialise} d;`<br/>
                        `\text{While}(x < X2)`<br/>
                        `\text{Do} x = x + 1;`<br/>
                        `\text{Test} d;`<br/>
                        `\text{Light appropriate pixel};`<br/>
                    `\text{Update} d;`</span></p>
                <br/>
                <u>Anti-aliasing</u>
                <p>Both of these algorithms produce very jagged-looking lines as only the required pixels light up. A solution to this would be anti-aliasing. This method will 
                    light up adjacent pixels to the line with a lower intensity to give it a smoothed off gradient look.</p>
                <br/>
                <u>Circle Drawing</u><br/>
                <u>Simple Algorithms Based on the Polar Parametric Representation</u>
                <p><img src="2D Computer Graphics/Image10.jpg" alt='Tenth Image'><br/>
                    `x(\phi) = r\cos\phi` and `y(\phi) = r\sin\phi`<br/>
                    With the rotation matrix<br/>
                    `\left\lgroup\matrix{\cos\epsilon & -\sin\epsilon\cr \sin\epsilon & \cos\epsilon}\right\rgroup`<br/>
                    `x(\phi + \epsilon) = x(\phi)\cos\epsilon - y(\phi)\sin\epsilon`<br/>
                    `y(\phi + \epsilon) = x(\phi)\sin\epsilon + y(\phi)\cos\epsilon`<br/>
                    In a discrete form for pixels, the equations are:<br/>
                    `x(n + 1) = x(n)\cos\epsilon - y(n)\sin\epsilon`<br/>
                    `y(n + 1) = y(n)\sin\epsilon + y(n)\cos\epsilon`<br/>
                    From (r, 0), the pixels can be created like so<br/>
                    <span style='color:red;'>`\text{Choose small value for \epsilon value};`<br/>
                        `s = \sin\epsilon;`<br/>
                        `c = \cos\epsilon;`<br/>
                        `n = 1;`<br/>
                        `x_1 = r;`<br/>
                        `y_1 = 0`<br/>
                        `\text{Write Pixel}(x_1, y_1, \text{value});`<br/>
                        `\text{Repeat}`<br/>
                        `x_{n + 1} = x_n(c) - y_n(s);`<br/>
                        `y_{n + 1} = x_n(s) - y_n(c);`<br/>
                        `\text{Write Pixel}(\text{floor}(x_{n + 1} + 0.5), \text{floor}{y_{n + 1} + 0.5, \text{value});`<br/>
                        `\text{Until}()`</span><br/>
                    If `x_{n + 1} - x_n > 1` or `y_{n + 1} - y_n > 1`, then the value for `/epsilon` is too large. This will cause holes to be seen in the curved line of the 
                    circle. The 8-way symmetry of the circle is useful to divide computation in an algorithm, as with the coordinate (x, y) that crosses over the circle, so must 
                    (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x).</p>
                <br/>
                <u>Bresenhem's Circle Algorithm</u>
                <p>A quadrant or an eighth of a circle is used in Bresenham's algorithm to work out the pixel pattern for one eighth of a circle and thus the eight times more 
                    pixels that overall need to be pinpointed. The centre is generally (0, 0) and the quadrant starts at x = 0, y = r to<br/>
                    `x = y = \frac r{sqrt(2)}`<br/>
                    As each pixel is covered, the midpoint must be assessed and the two possible pixel points are given. If the midpoint lies in the circle then it will be the 
                    outer point and if it lies outside of the circle, the inner point will be lit. After the procedure has been completed, two new possible pixel points are chosen 
                    from the last pixel point that was lit and as well as this a new midpoint is generated from the two possible midpoints that could've been branching from the 
                    last pixel.<br/>
                    Implicit - `F(x, y) = x^2 + y^2 - r^2 = 0`<br/>
                    Any test point will be inside the circle if `F(x_T, y_T) < 0` and outside the circle is 1F(x_T, y_T) > 0`<br/>
                    <span style='color:red;'>`\text{Procedure}: \text{bresenhem_circle}(r, \text{value:integer})`<br/>
                        `\text{var} x, y:\text{integer};`<br/>
                        `d:\text{real};`<br/>
                        `\text{Begin}`<br/>
                        `x = 0;`<br/>
                        `y = r;`<br/>
                        `d = \frac 54 - r;`<br/>
                        `\text{Eight Points}(x, y, \text{value});`<br/>
                        `\text{While} y > x \text{do}`<br/>
                        `\text{Begin}`<br/>
                        `\text{If}(d < 0)`<br/>
                        `\text{Begin}`<br/>
                        `d = d + 2(x) + 3;`<br/>
                        `x = x+ 1;`<br/>
                        `text{End}`<br/>
                        `\text{Else}`<br/>
                        `\text{Begin}`<br/>
                        `d = d + 2(x - y) + 5;`<br/>
                        `x = x + 1;`<br/>
                        `y = y - 1;`<br/>
                        `\text{End}`<br/>
                        `\text{Eight Points}(x, y, \text{value});`<br/>
                        `\text{End}`<br/>
                        `\text{End}`</span></p>
                <br/>
                <u>Vector Clipping</u>
                <p>If a vector is drawn and it clips to outside of a raster display, then the vector should be clipped off so it does not waste any unnecessary memory. If the 
                    vector clips the edge of the raster display at (x*, y*), and the vector is from `(x_1, y_1)` to `(x_2, y_2)`. The visible vector would be shown from `(x_1, y_1)` to 
                    (x*, y*) and not to `(x_2, y_2)`.<br/>If the 4-bit code for both endpoints is 0000, then no clipping is required as both endpoints are within the raster display. 
                    If the bitwise and of the endpoints of the line is not equal to 0000, the whole line will be outside of the raster display. If the endpoints are both , 
                    all entirely above, below, to the left or to the right of the clipping rectangle, then those lines are not in the clipping rectangle.<br/>If the anded code is 
                    0000, the line may be partially visible, or it may be completely invisible.<br/>The Cohen-Sutherland algorithm will clip any straight lines that fail tests 1 
                    and 2. The algorithm will then expand the boundary edges until the straight lines pass tests 1 and 2.</p>
                <br/>
                <u>Polygon Clipping</u>
                <p>Polygons will be stored on the raster display but some of their edges may lie outside of the boundary. If this is so, then the polygon will have to be 
                    appropriately clipped until all of the vertices of the polygon lie inside the boundary.<br/>A polygon will be stored as a set of vertices, all in order and a 
                    set of edges with pairs of vertices limiting the edge length.<br/>Clipping polygons can produce 0 or above different clipped polygons in the raster display 
                    area.<br/>The outputted clipped polygons should have the same data structure as the initial unclipped polygon.</p>
                <br/>
                <u>Scan-converting Polygons</u><br/>
                <u>Using an Inside Test</u>
                <p>The inside test is a test to see what pixels lie inside a polygon's confines and need to be lit. It is a very inefficient test, even if the extent of the polygon 
                    P is used to limit the number of pixels to be analysed.</p>
                <br/>
                <u>A Scanline Algorithm</u>
                <p>In this case, one axis is used as a line system and the polygon is scanned on the plane from the top down. The line that is being scanned is split up into pairs 
                    of coordinates that map the actual body of the polygon. The pixels in between these pairs are lit up.</p>
                <br/>
                <u>An Improved Scanline Method</u>
                <p>The above scanline algorithm only partially exploits the scanline coherence. With an improved algorithm, the edge coherence can also be exploited.<br/>Brute 
                    force calculation of intersection points should be avoided. Only a small number of intersections should pass through the scanline. Most of the edges intersected 
                    by the ith scanline, should in general also be intersected by the i+1th scanline. The intersection data should be very similar in adjacent scanlines.<br/>This 
                    improved scanline method will not completely delete the Active Edge Table once the next scanline is being analysed. It will retain the edge values that still 
                    intersect the new scanline, old intersections that are no longer present will be removed and newer intersections that were not there in the previous scanline 
                    will be added.<br/>Each global edge table will contain a `y_{\text{max}}` value, an `x_{\text{min}}` value and the `\frac 1m` value.</p>
                <br/>
                <u>Independence Requirements</u>
                <p>Graphics displays should contain software that is generally interchangeable between operating systems. This means that it requires at little procedure at all to 
                    be able to play this piece of software on one computer and then play the same piece of software on another, different computer. The graphics software packages 
                    should also be interchangeable between application and hardware devices of the computer. If the software packages are written in high-level programming 
                    languages, then generally this can be achieved.<br/>It is not always possible though as some computer systems might be colour and some displays may be 
                    monochrome. As well as this some computers can use raster displays or vector displays, which aren't very interchangeable.<br/>If general functions and classes 
                    are implemented into the software then the software won't be application-specific and will be interchangeable between applications.</p>
                <br/>
                <u>Functional Requirements</u>
                <p>There is a set of functional requirements needed for a graphics software package.<br/>Firstly, these pieces of software must have procedures for drawing straight 
                    lines, circles, squares and other geometric primitives.<br/>Secondly, the pieces of software must have viewing pieces of software for both the 2 and 3D objects.<br/>
                    Thirdly, there must be functions to provide segmentation to objects.<br/>Fourthly, there must be functions to be able to transform objects from one place to another 
                    or rotate the object or scale the object, or even any combination of the three.<br/>Fifthly, there must be provision for input from I/O devices like keyboards and 
                    mice.<br/>Lastly, there must be general facilities like being able to remove objects and requesting device characteristics.</p>
                <br/>
                <u>Coordinate Systems, Viewing Transformations</u><br/>
                <u>Device Coordinates</u>
                <p>Device coordinates typically involve resolution size of monitors rather than anything else, so the number of addressable, lightable points for a computer display.<br/>
                    (0, 0) will be the top left point of the raster display.</p>
                <br/>
                <u>World Coordinates</u>
                <p>World coordinates apply the same basic limitations to a plane but they use units and not arbitrary values. These units can include metres, centimetres, miles 
                    etc.<br/>These coordinates would be better for physics-relating systems or with building projects where real-world dimensions will have to be realised.</p>
                <br/>
                <u>A Simple Outline Pipeline</u>
                <p>The output line will transform the coordinated object into a displayable image in the raster display.<br/>Define boundary edges `\rightarrow` Clip to window limits `\rightarrow` Define 
                    viewport limits `\rightarrow` Transform window to viewport `\rightarrow` Display</p>
                <br/>
                <u>An Alternative Output Pipeline</u>
                <p>Each device will have a normalized display space, providing a standard system of coordinates, this is a convenient way of holding graphical data in a display.<br/>
                    Scaling an object will involve normalizing the display space to a viewport for that object and setting the lower left vertex as (0, 0) and the top right vertex 
                    as (M, N) where M and N are the new scaled coordinates, `M = \lambda x` and `N = \mu y`. Then the viewport will become the updated graphics display.</p>
                <br/>
                <u>A Virtual Input Model</u>
                <p>There are several virtual input devices that will provide certain functionality or data structures to it. The examples are LOCATOR which will provide a position 
                    in world coordinates. VALUATOR will provide a real number, CHOICE which is a positive integer for any n number of different values, (0 will provide no choice), 
                    PICK will provide a reference point for a certain image/segment in a raster display, STRING provide a character string, STROKE will provide a string of x, y 
                    coordinates in world coordinates.<br/>A virtual input device will have measure, trigger, prompt and echo as processes. The measure process is to tell whether 
                    the virtual input device is interacting with something. The trigger process will signify significant moments in a procedure by firing when these moments take 
                    place. A prompt is a process to tell the user that the input device is ready.<br/>There are three modes of operation for each process. The first mode of 
                    operation is REQUEST where the computer is waiting for the user to input a string and signify the completion of the request with a mouse click or something 
                    similar. SAMPLE is in a sense, the asynchronous form of REQUEST. SAMPLE will not wait for user's input or delimiter click to request an input, instead it will 
                    output the current input value of the input device. EVENT mode will create event reports asynchronously  by user action only from devices in EVENT mode. The 
                    virtual input device can also obtain the first event report by using AWAIT EVENT. As well as this, the user can also flush all the event reports from the 
                    queue.<br/>REQUEST mode is a singular form of EVENT mode where EVENT mode will produce a queue and REQUEST mode will simply output the first trigger. The SAMPLE 
                    mode will simply have an inoperable trigger that simply measures each call to SAMPLE.</p>
                <br/>
                <u>Graphics Standards</u>
                <p>Graphics standards were developed in the 1980's like the GINO and CORE systems for Europe and the USA were developed and later on in the '80's, the GKS was 
                    developed; the first international graphics standard, which quickly became obsolete because of  developing technology. Open GL is a current graphics standard 
                    but at the moment there aren't any international standards.</p>
            </div>
        </div>
    </body>
</html>